# Roslyn-Analyzer

> Данный репозиторий представляет собой анализатор и кодфиксер, написанный с использованием `Roslyn API`

## Кейсы для анализа и фиксов

1. Возвращение `null` значения вместо пустой коллекции в методах, возвращаемым типом которых является коллекция
    - В том числе кейсы, где есть `yield return`
2. Использование непереопределённого оператора `==` для сравнения типов (вместо `.Equals`)

## Фиксы

1. В случае, когда возвращаемый тип у коллекций - один из: [`IEnumerable`, `IList`, `ICollection`, `IReadOnlyCollection`, `List`, `IReadOnlyList`, `SortedList`] или `Array` и возвращается `null` вместо пустой коллекци
    - Кидается диагностика о том, что это нужно фиксить
    - В случае обычного `return`
        - `Array<T>` - `null` заменяется на `return new T[] { }`
        - `List<T>` - `null` заменяется на `return new List<T>()`
        - В остальных случаях - `null` заменяется на `return Array.Empty<T>()`
    - В случае `yeld return`
        - `IEnumerable<T[]>` - `null` заменяется на `yeld return new T[] { }`
        - `IEnumerable<List<T>>` - `null` заменяется на `yeld return new List<T>()`
        - В остальных случаях - `null` заменяется на `yeld return Array.Empty<T>()`

2. В случае, когда используется оператор `==` требуется проанализировать базовые классы от сравниваемых, чтобы проанализировать, есть ли у них перегрузка `==` или `.Equals`
    - Если оба операнда, являющиеся `ref type`, НЕ имеют перегрузки `==` (учитывая базовые классы) - диагностика кидается и `==` заменяется на `.Equals`
    - Если оба операнда, являющиеся `ref type`, имеют перегрузки `==` (учитывая базовые классы) - диагностика не кидается
    - Если оба операнда, являются `value type` - диагностика не кидается
    - Если левый операнд имеет перегрузку `==` (учитывая базовые классы), а правый не имеет - диагностика не кидается
    - Если правый операнд имеет перегрузку, а правый не имеет - диагностика кидается и `==` заменяется на `.Equals`
    - Если хотя бы один операнд является `interface` - диагностика не кидается

Стоит заметить что анализатор сразу отбрасывает случаи, когда хотя бы один операнд является `value type` или `interface`, т.к. сравнение `value types` по дефолту идёт посредством сопоставления всех полей 2х операндов, а реализовать сравнение у интерфейсов довольно проблематично.